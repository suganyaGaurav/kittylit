rag_pipeline Folder – Overview

The rag_pipeline/ module contains all components required for Retrieval-Augmented Generation (RAG) inside the KittyLit system.
It is built with a modular, explainable structure so each part can be understood, tested, and extended independently.

This pipeline powers: 
* Semantic search
* Book retrieval
* Embedding generation
* Vector database operations
* End-to-end retrieval flow for the HelpBot & recommendation engine
* Below is a description of each file and its role in the system.

File Descriptions

1. __init__.py : Initializes the RAG Pipeline package. Ensures clean imports and prepares the namespace for embedding + retriever components.

2. embeddings.py : Handles all embedding-related operations.

Key Responsibilities:

* Load embedding models (MiniLM, OpenAI, or custom).
* Convert queries and book text into vector embeddings.
* Provide unified functions like encode_query() and encode_documents().

Purpose: Standardized embeddings across RAG, Agents, and Chatbot.

3. retriever.py : Implements the actual retrieval mechanism.

Responsibilities:

* Load FAISS or other vector index.
* Perform similarity search.
* Apply top-k filtering and scoring.
* Prepare results for ranking/merging modules.

Purpose: Core “search engine” of the system.

4. test_rag_cli.py : A simple CLI script for manual testing.

Responsibilities:

* Run RAG pipeline end-to-end from the terminal.
* Allow developers to test embeddings + retrieval without running the whole app.
* Useful during debugging and fine-tuning.

Purpose: Developer-focused test harness.

5. untitled (temporary file) : Placeholder or scratch file. Not part of the production pipeline. To be cleaned or converted into design notes later.

Folder Sub-directories

1. .ipynb_checkpoints/ :

* Auto-generated by Jupyter.
* Contains notebook checkpoints.
* Not used by the pipeline.

2. __pycache__/ : 

* Auto-generated Python cache.
* Ignored in GitHub via .gitignore.

Design Principles : 

* Separation of concerns – embeddings, retrieval, and testing are isolated.

* Explainable architecture – each module has a single responsibility.

* RAG-first design – scalable for adding rerankers, hybrid search, or LLM-based query reformulation.

* Future-ready – can integrate with Agents, Chatbot, or external APIs.
